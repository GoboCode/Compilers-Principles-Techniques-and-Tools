### 2.2.1
***
Consider the context-free grammar
```
        S -> S S + | S S * | a
```

a) Show how the string **aa+a*** can be generated by this grammar.

b) Construct a parse tree for this string.

c) What language does this grammar generate? Justify your answer.

### `Answer`
a)
```
S -> S S * -> S a * -> S S + a * -> S a + a * -> a a + a *
```

c) L = {Postfix expression consisiting of digits, plus and multiple signs}

### 2.2.2
***
What language is generated by the following grammars? In each case justify your answer.

a) S -> 0 S 1 | 0 1

b) S -> + S S | - S S | a

c) S -> S ( S ) S | ε

d) S -> a S b S | b S a S | ε

e) S -> a | S + S | S S | S * | ( S )

### `Answer`
a) L = {0<sup>n</sup>1<sup>n</sup>| n >= 1}

b) L = {Prefix expression consisiting of digits, plus and multiple signs}

c) L = {Matched brackets of arbitrary arrangement and nesting, includes ε}

d) L = {Number of a's = Number of b's, includes ε}

e) L = {Regular expressions used to describe regular languages}

### 2.2.3
***
Which of the grammars in Exercise 2.2.2 are ambiguous?

### `Answer`
c), d) and e)

### 2.2.4
***
Construct unambiguous context-free grammars for each of the following languages. In each case show that your grammar is correct.

a) Arithmetic expressions in postfix notation.

b) Left-associative lists of identifiers separated by commas.

c) Right-associative lists of identifiers separated by commas.

d) Arithmetic expressions of integers and identifiers with the four binary operators +, -, *, /.

e) Add unary plus and minus in the arithmetic operators of (d).

### `Answer`
a)
```
E -> E E op | num
```
b)
```
list -> list , id | id
```
c)
```
list -> id , list | id
```
d)
```
  expr -> expr + term | expr - term | term
  term -> term * factor | term / factor | factor
factor -> num | id | (expr)
```
e)
```
  expr -> expr + term | expr - term | term
  term -> term * unary | term / unary | unary
 unary -> + factor | - factor | factor
factor -> num | id | (expr)
```

### 2.2.5
***
a) Show that all binary strings generated by the following grammar have values divisible by 3. *Hint.* Use induction on the number of nodes in a parse tree.
```
        num -> 11 | 1001 | num 0 | num num
```
b) Does the grammar generate all binary strings with values divisible by 3?

### `Answer`
Any natural number n is divisible by 3 if it can be represented in the form 3k, where k is a natural number less than n.

a) The first production, 11<sub>2</sub> = 3<sub>10</sub>, is divisible by 3.

The second production, 1001<sub>2</sub> = 9<sub>10</sub>, is divisible by 3.

Lets call the first two productions as S = 3r.

The third production adds a 0 at the suffix of the binary string, which implies multiplying the number by 2<sup>n</sup>, where n is the number of times the third production is generated.

Hence the third production, 2<sup>n</sup>S = 2<sup>n</sup>(3r) = 3(2<sup>n</sup>r), is divisible by 3.

The fourth production can be defined as S -> S<sub>1</sub> S<sub>2</sub>, which implies multiplying S<sub>1</sub> by 2<sup>n</sup>, where n is the number of bits in S<sub>2</sub>, and adding S<sub>2</sub> to the product of multiplication.

Hence the fourth production, 2<sup>n</sup>S<sub>1</sub> + S<sub>2</sub> = 2<sup>n</sup>3r + 3r = 3(2<sup>n</sup> + r), is divisible by 3.

Therefore, we can conclude that S is always divisible by 3.

b) No. Consider the binary string 10101, which is divisible by 3, but cannot be derived from the grammar.

Consider the grammar,
```
        num -> 11 | 1001 | num 0 | num num
```

Since num can be represented as 3k,
```
        num = 3k -> 11 | 1001 | num 0 | num num
```

Dividing both sides of the production by 3,
```
        num/3 = k -> 01 | 0011 | num/3 0 | num/3 num/3
```
Or,
```
        k -> 01 | 0011 | k 0 | k k
```

10101<sub>2</sub> = 21<sub>10</sub> = 3 * 7.

If k = 7<sub>10</sub> = 111<sub>2</sub>, there is no way that 111 could be derived from the following grammar. Therefore, num cannot derive 10101 from its grammar.

### 2.2.6
***
Construct a context-free grammar for roman numerals.

### `Answer`
Considering values from 1 to 3999 inclusive,

```
          num -> thousands hundreds tens ones
    thousands -> M | MM | MMM | ε
     hundreds -> smallhundreds | CD | D | D smallhundreds | CM | ε
smallhundreds -> C | CC | CCC
         tens -> smalltens | XL | L | L smalltens | XC | ε
    smalltens -> X | XX | XXX
         ones -> smallones | IV | V | V smallones | IX | ε
    smallones -> I | II | III
```
